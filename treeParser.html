<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>TREE DATA TO SVG CONVERTER</title>
    <style>
    </style>
	<script src="data.json" type="text/json"></script>
    <script>
		var passiveSkillTreeData;
		fetch("data.json").then(response => response.json()).then(parsed => {
			passiveSkillTreeData = parsed;
			init();
		}); 
      function init() {
        const shiftX = passiveSkillTreeData.min_x;
        const shiftY = passiveSkillTreeData.min_y;

        const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
        svg.setAttribute("viewBox","0 0 " + (passiveSkillTreeData.max_x-shiftX) + " " + (passiveSkillTreeData.max_y-shiftY));
        svg.setAttribute("width","1000");
        svg.setAttribute("height","1000");

        // keep a map of nodes that matters
        const nodeMap = new Map();
        for( let[key, value] of Object.entries(passiveSkillTreeData.nodes)) {
          if(!value.isAscendancyStart && !value.isMultipleChoice && !value.isMultipleChoiceOption && !value.isMastery && !value.ascendancyName && (!value.spc || value.spc.length == 0)) {
            nodeMap[key] = value;
            //if(value.ks) console.log(value);
          }
        }
        //console.log("filter out ", nodeMap);

        // Parse the groups to get coordinate of the center of circle if needed
        for( let [key, value] of Object.entries(passiveSkillTreeData.groups)) {
	  if(!value.isProxy) {
	    // Orbit are at radius 0 when node is at the center
	    for( let orbit of value.orbits) {
	      // get the radius of the orbits from the groupNode
	      const radius = passiveSkillTreeData.constants.orbitRadii[orbit];
	      // DEBUG: drawing the circle
	      const groupNode = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	      groupNode.setAttribute("cx", value.x -shiftX);
	      groupNode.setAttribute("cy", value.y -shiftY);
	      groupNode.setAttribute("r", radius);
	      groupNode.setAttribute("stroke", "#00F");
	      groupNode.setAttribute("stroke-width", value.nodes.length);
	      groupNode.setAttribute("fill", "none");
	      svg.appendChild(groupNode);
		    
              // Read only the nodes that matters
              const filteredNode = value.nodes.filter(function (node) {return nodeMap[node]; });
              for( let node of filteredNode) {
		// Number of point on the circle
                const skillOrbit = passiveSkillTreeData.constants.skillsPerOrbit[passiveSkillTreeData.nodes[node].orbit];
                const nodePoint = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	        // Place the node in the orbit and use orbit position to get him at the right location
		if(skillOrbit != 0 && radius != 0) {
	          nodePoint.setAttribute("cx", value.x -shiftX + (Math.sin(Math.PI*2*passiveSkillTreeData.nodes[node].orbitIndex/skillOrbit)*radius));
                  nodePoint.setAttribute("cy", value.y -shiftY - (Math.cos(Math.PI*2*passiveSkillTreeData.nodes[node].orbitIndex/skillOrbit)*radius));
		} else {
		  nodePoint.setAttribute("cx", value.x -shiftX);
                  nodePoint.setAttribute("cy", value.y -shiftY);
		}
	        if(node.isKeystone) {
                  nodePoint.setAttribute("fill", "#F00");
	          nodePoint.setAttribute("r", 128);
	        } else if(node.isNotable) {
                  nodePoint.setAttribute("fill", "#0F0");
	          nodePoint.setAttribute("r", 64);
	        } else {
                  nodePoint.setAttribute("fill", "#292");
	          nodePoint.setAttribute("r", 32);
	        }
                svg.appendChild(nodePoint);
	      }
            } 
	  } else {
            // Read only the nodes that matters
            const filteredNode = value.nodes.filter(function (node) {return nodeMap[node]; });
            for( let node of filteredNode) {
              const nodePoint = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	      nodePoint.setAttribute("cx", value.x -shiftX);
	      nodePoint.setAttribute("cy", value.y -shiftY);
	      if(node.isKeystone) {
                nodePoint.setAttribute("fill", "#F00");
	        nodePoint.setAttribute("r", 128);
	      } else if(node.isNotable) {
                nodePoint.setAttribute("fill", "#00F");
	        nodePoint.setAttribute("r", 64);
	      } else {
                nodePoint.setAttribute("fill", "#229");
	        nodePoint.setAttribute("r", 32);
	      }
              svg.appendChild(nodePoint);
	    }
	  }
          //console.log(value.oo);
        };

        document.getElementById("maindiv").appendChild(svg);
        console.log(passiveSkillTreeData);
      }
    </script>
  </head>
	<body>
		<div id="maindiv" style="overflow: auto">
		</div>
	</body>
</html>
