<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>TREE DATA TO SVG CONVERTER</title>
    <style>
    </style>
	<script src="data.json" type="text/json"></script>
    <script>
		var passiveSkillTreeData;
		fetch("data.json").then(response => response.json()).then(parsed => {
			passiveSkillTreeData = parsed;
			init();
		}); 
      function init() {
        const shiftX = passiveSkillTreeData.min_x;
        const shiftY = passiveSkillTreeData.min_y;

        const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
        svg.setAttribute("viewBox","3000 3000 " + (passiveSkillTreeData.max_x-shiftX) + " " + (passiveSkillTreeData.max_y-shiftY));
        svg.setAttribute("width","1000");
        svg.setAttribute("height","1000");

        // keep a map of nodes that matters
        const nodeMap = new Map();
        for( let[key, value] of Object.entries(passiveSkillTreeData.nodes)) {
          if(!value.isAscendancyStart && !value.isMultipleChoice && !value.isMultipleChoiceOption && !value.isMastery && !value.ascendancyName 
	     && !value.isBlighted && (!value.spc || value.spc.length == 0)) {
            nodeMap[key] = value;
            //if(value.ks) console.log(value);
          }
        }
        //console.log("filter out ", nodeMap);

        // Parse the groups to get coordinate of the center of circle if needed
        for( let [key, value] of Object.entries(passiveSkillTreeData.groups)) {
	  if(!value.isProxy) {
	    // Orbit are at radius 0 when node is at the center
	    for( let orbit of value.orbits) {
	      // get the radius of the orbits from the groupNode
	      const radius = passiveSkillTreeData.constants.orbitRadii[orbit];		    
              // Read only the nodes that matters
              const filteredNode = value.nodes.filter(function (node) {return nodeMap[node] && nodeMap[node].orbit == orbit; });
	      // DEBUG: drawing the circle
	      if(filteredNode.length > 0) {
	        const groupNode = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	        groupNode.setAttribute("cx", value.x -shiftX);
	        groupNode.setAttribute("cy", value.y -shiftY);
	        groupNode.setAttribute("r", radius);
	        groupNode.setAttribute("stroke", "#00F");
	        groupNode.setAttribute("stroke-width", value.nodes.length);
	        groupNode.setAttribute("fill", "none");
	        groupNode.setAttribute("id", "group"+key+":"+orbit);
	        svg.appendChild(groupNode);
	      }

              for( let node of filteredNode) {
		const nodeObject = nodeMap[node];
		// Number of point on the circle
                const skillOrbit = passiveSkillTreeData.constants.skillsPerOrbit[nodeObject.orbit];
                const nodePoint = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	        // Place the node in the orbit and use orbit position to get him at the right location
		if(skillOrbit != 0 && radius != 0) {
	          nodePoint.setAttribute("cx", value.x -shiftX + (Math.sin(Math.PI*2*nodeObject.orbitIndex/skillOrbit)*radius));
                  nodePoint.setAttribute("cy", value.y -shiftY - (Math.cos(Math.PI*2*nodeObject.orbitIndex/skillOrbit)*radius));
		  nodeObject.x = value.x -shiftX + (Math.sin(Math.PI*2*nodeObject.orbitIndex/skillOrbit)*radius);
		  nodeObject.y = value.y -shiftY - (Math.cos(Math.PI*2*nodeObject.orbitIndex/skillOrbit)*radius);
		} else {
		  nodePoint.setAttribute("cx", value.x -shiftX);
                  nodePoint.setAttribute("cy", value.y -shiftY);
		  nodeObject.x = value.x -shiftX;
		  nodeObject.y = value.y -shiftY;
		}
		nodeMap[node] = nodeObject;
	        if(nodeObject.isKeystone) {
                  nodePoint.setAttribute("fill", "#F00");
	          nodePoint.setAttribute("r", 128);
	        } else if(nodeObject.isNotable) {
                  nodePoint.setAttribute("fill", "#0F0");
	          nodePoint.setAttribute("r", 64);
	        } else {
                  nodePoint.setAttribute("fill", "#292");
	          nodePoint.setAttribute("r", 32);
	        }
	        nodePoint.setAttribute("id", "node"+node);
                svg.appendChild(nodePoint);
	      }
            }
	  }
          //console.log(value.oo);
        };
	      
	// Drawing the links between nodes
	for( let[key, value] of Object.entries(nodeMap)) {
		// Some nodes got no x or y ? FIXME research this further
		if(value.out && value.x && value.y)
		for( let nodeTo of value.out) {
			const target = nodeMap[nodeTo];
			// Some nodes out point to ascendancy or large cluster jewel
			if(target && target.x && target.y) {
				// If nodes are of the same group with orbit, draw arc
				if(target.group == value.group && target.orbit == value.orbit && passiveSkillTreeData.constants.orbitRadii[target.orbit] != 0) {
					const nodeConnection = document.createElementNS("http://www.w3.org/2000/svg", "path");
					let isBefore = if(value.orbitIndex > target.orbitIndex) "1" else "0"
					nodeConnection.setAttribute("d", "M " + value.x + " " + value.y + " A " 
								    + passiveSkillTreeData.constants.orbitRadii[target.orbit] + " " 
								    + passiveSkillTreeData.constants.orbitRadii[target.orbit] + " 0 0 "
								    + isBefore + " " + target.x + " " + target.y);
					nodeConnection.setAttribute("style", "stroke:#00F;stroke-width:8;stroke-dasharray:16");
					svg.appendChild(nodeConnection);
				// If not, draw line
				} else {
					const nodeConnection = document.createElementNS("http://www.w3.org/2000/svg", "line");
					nodeConnection.setAttribute("x1", value.x);
					nodeConnection.setAttribute("y1", value.y);
					nodeConnection.setAttribute("x2", target.x);
					nodeConnection.setAttribute("y2", target.y);
					nodeConnection.setAttribute("style", "stroke:#229;stroke-width:8;stroke-dasharray:16");
					svg.appendChild(nodeConnection);
				}
			}
		}
                
	}
	
        document.getElementById("maindiv").appendChild(svg);
        console.log(passiveSkillTreeData);
      }
    </script>
  </head>
	<body>
		<div id="maindiv" style="overflow: auto">
		</div>
	</body>
</html>
