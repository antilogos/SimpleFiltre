<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>TREE DATA TO SVG CONVERTER</title>
	<link rel="shortcut icon" type="image/png" href="https://docs.google.com/drawings/d/e/2PACX-1vRmsUqz_w0baXylHjox1oadVVCB2B0kq8LtyvLEx9M7rZTjSr18UDf0IaDljbf5db3uUkd2Fi9MRwHX/pub?w=51&h=50"/>
	<style>
	</style>
	<script src="data.json" type="text/json"></script>
	<script src="tutorialPath.js" type="text/javascript"></script>
    	<script src="parser.js" type="text/javascript"></script>
    	<script>
	var passiveSkillTreeData;
	var nodes;
	fetch("data.json").then(response => response.json()).then(parsed => {
		passiveSkillTreeData = parsed;
		nodes = extractNodesData(parsed);
		init();
	});
	const urlParams = new URLSearchParams(window.location.search);
			
	function init() {
		const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
		svg.setAttribute("width","800");
		svg.setAttribute("height","800");

		// Drawing the links between nodes
		for( let[key, value] of Object.entries(nodes)) {
			// Some nodes got no x or y ? FIXME research this further
			if(value.out && value.x && value.y)
			for( let nodeTo of value.out) {
				const target = nodes[nodeTo];
				// Some nodes out point to ascendancy or large cluster jewel
				if(target && target.x && target.y) {
					// If nodes are of the same group with orbit, draw arc
					svg.appendChild(buildSvgConnection(value, target, passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii));
				}
			}
		}
		for( let[key, value] of Object.entries(nodes)) {
			if(value.id) svg.appendChild(buildSvgNode(value));
		}
		
		// Draw a tutorial skill tree
		if(urlParams.get("draw")) {
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["b4"]), "#1155cc",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["b3"]), "#6d9eeb",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["b2"]), "#38761d",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["b1"]), "#93c47d",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["e1"]), "#134f5c;stroke-dasharray:16",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["e2"]), "#990000;stroke-dasharray:16",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
			buildPath(parseUrl(tutorial[urlParams.get("draw")]["e3"]), "#bf9000;stroke-dasharray:16",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
		} else if(urlParams.get("hash")) {
			buildPath(parseUrl(urlParams.get("hash")), "#00F",svg,nodes,passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii);
		}

		let minViewX = Math.ceil(Math.min(...Object.entries(nodes).filter(n => n[1].x).map(n => n[1].x)));
		let minViewY = Math.ceil(Math.min(...Object.entries(nodes).filter(n => n[1].y).map(n => n[1].y)));
		let maxViewX = Math.ceil(Math.max(...Object.entries(nodes).filter(n => n[1].x).map(n => n[1].x)));
		let maxViewY = Math.ceil(Math.max(...Object.entries(nodes).filter(n => n[1].y).map(n => n[1].y)));
		svg.setAttribute("viewBox",(minViewX -150) + " " + (minViewY -150) + " " + (maxViewX-minViewX +300) + " " + (maxViewY-minViewY +300));
		document.getElementById("maindiv").appendChild(svg);
	}
	</script>
</head>
	<body>
		<div id="maindiv" style="overflow: auto">
		</div>
	</body>
</html>
