<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>TREE DATA TO SVG CONVERTER</title>
    <style>
    </style>
	<script src="data.json" type="text/json"></script>
    <script src="parser.js" type="text/javascript"></script>
    <script>
	var passiveSkillTreeData;
	var nodes;
	fetch("data.json").then(response => response.json()).then(parsed => {
		passiveSkillTreeData = parsed;
		nodes = extractNodesData(parsed);
		init();
	});
	
	function init() {
		const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
		svg.setAttribute("width","800");
		svg.setAttribute("height","800");

		// Drawing the links between nodes
		for( let[key, value] of Object.entries(nodes)) {
			// Some nodes got no x or y ? FIXME research this further
			if(value.out && value.x && value.y)
			for( let nodeTo of value.out) {
				const target = nodes[nodeTo];
				// Some nodes out point to ascendancy or large cluster jewel
				if(target && target.x && target.y) {
					// If nodes are of the same group with orbit, draw arc
					svg.appendChild(buildSvgConnection(value, target, passiveSkillTreeData.constants.skillsPerOrbit, passiveSkillTreeData.constants.orbitRadii));
				}
			}
		}
		for( let[key, value] of Object.entries(nodes)) {
			if(value.id) svg.appendChild(buildSvgNode(value));
		}

		let minViewX = Math.ceil(Math.min(...Object.entries(nodes).filter(n => n[1].x).map(n => n[1].x)));
		let minViewY = Math.ceil(Math.min(...Object.entries(nodes).filter(n => n[1].y).map(n => n[1].y)));
		let maxViewX = Math.ceil(Math.max(...Object.entries(nodes).filter(n => n[1].x).map(n => n[1].x)));
		let maxViewY = Math.ceil(Math.max(...Object.entries(nodes).filter(n => n[1].y).map(n => n[1].y)));

		svg.setAttribute("viewBox",(minViewX -150) + " " + (minViewY -150) + " " + (maxViewX-minViewX +300) + " " + (maxViewY-minViewY +300));
		document.getElementById("maindiv").appendChild(svg);
	}
    </script>
  </head>
	<body>
		<div id="maindiv" style="overflow: auto">
		</div>
	</body>
</html>
